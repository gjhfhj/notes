# c++ notes  
Cpp 的可移植性是通过基于不同cpu适配了的cpp编译器来实现在不同设备上运行同一个程序  
  
> “使用合适的编译器或编译器集，便可把一种高级语言程序转换成供各种不同类型 CPU 使用的机器语言程序。”  
>   
> Excerpt From  
> 
> C Primer Plus 第6版 中文版  
> 
> [美]史蒂芬·普拉达（Stephen Prata） [[美]史蒂芬·普拉达（Stephen Prata）]  
> 
> This material may be protected by copyright.  
  
编译器把源代转换成中间代码, 链接器把中间代码和其他代码合并, 生成可执行文件. **==C使用这种分而治之的方法方便对程序进行模块化, 能独立编译单独的模块, 再通过链接器合并.==**  
  
> “将依赖于硬件部分放在函数模块中可以租大限度地降低可移植性问题; 这样只需要重新编写这些模块即可.“  
  
  
==注意: == 我程序通过编译并不代表程序合法, 不能通过编译也未必非法  
```
提示:
    有时, 编译器在不完全地构建程序后将出现混乱, 显示无法改正的, 无意义的错误消息. Build All重新编译即可
    遗憾的是: 这种情况和那些更常见的情况(即错误消息看上去无意义, 实际上有意义)很难区分

```
  
## 关于cpp的各代标准  
C++98, 不仅仅描述了已有的C++特性, 还对语言进行了扩展, 添加了异常、运行阶段类型识别(RTTI)、模版喝标注模版裤  
C++03没有改变语言特性,   

| 标准名称 | 发布年份 | 常用简称 | 主要变化关键词 | 主要特性 |
| --------- | --------- | -------------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| C++98 | 1998 | C++98 | Bjarne Stroustrup 于 1983 年基于 C 开发，经历 “C with Classes” → “ARM C++”，1998 年正式标准化 | 引入 class、template、namespace、exception、STL（标准模板库） |
| C++03 | 2003 | C++03 | 修复 C++98 的歧义与实现问题 | 模板规则修正、标准库改进、value initialization、为 C++11 铺路 |
| C++11 | 2011 | C++11 (“Modern C++”) | 现代 C++ 起点，提升可用性、性能与安全性 | 智能指针、lambda 表达式、auto 类型推导、右值引用与移动语义、并发库、range-based for |
| C++14 | 2014 | C++14 | 语法完善与功能增强 | 泛型 lambda、make_unique、数字分隔符、constexpr 强化、返回类型自动推导 |
| C++17 | 2017 | C++17 | 实用与性能导向更新 | if/switch 初始化、结构化绑定、std::optional / std::variant / std::any、std::filesystem、并行算法 |
| C++20 | 2020 | C++20 | 重大更新：模块化与概念化 | 模块（Modules）、概念（Concepts）、协程（Coroutines）、ranges、三路比较 <=>、consteval、span |
| C++23 | 2023 | C++23 | 语法细化与标准库增强 | std::expected、std::print、import std;、ranges 扩展、网络库试验性加入 |
| C++26（预计） | 2026（开发中） | C++26 | 扩展元编程与并行模型 | 静态反射、执行器模型（Executors）、正式网络库、编译期编程增强 |
  
  
  
  
  
# 典型语法/机制  
c++ 的重要核心特性基本由其语法/机制来实现的.  
  
## ==语法部门:==左值右值:  
```
能取地址的、有名字的、在内存中存在的被归类为左值, 特点:有持久的存储空间

```
```
int x = 10;   // x 是左值
int* p = &x;  // 可以取地址

```
```
没有名字的临时值, 不能直接取地址的被归为右值, 特点: 通常是表达式结果或者字面常量, 生命周期短

```
```
int y = 5;    // 5 是右值（字面量）
int z = x + y; // (x + y) 的结果是右值

```
  

| 类型       | 能绑定的值        | 生命周期延长          | 是否可修改  | 是否可 move | 常见用途      |
| -------- | ------------ | --------------- | ------ | -------- | --------- |
| T&       | 只能绑定左值       | ❌ 不延长           | ✅ 可修改  | ❌        | 普通引用参数    |
| const T& | 左值 + 右值      | ✅ 延长右值到引用作用域    | ❌ 不可修改 | ❌        | 只读引用，避免拷贝 |
| T&&      | 只能绑定右值（临时对象） | ✅ 接管右值（本身作用域有效） | ✅ 可修改  | ✅        | 移动语义、完美转发 |
  
## ==语法部门:==const:  
### **	1. 成员函数后的 const**  
```
void wait() const;

```
这里const修饰成员函数, 这个函数 **不会修改类的成员变量**（即不会改变对象状态）。  
这样，当你有一个 const ThreadPool 对象时，它也可以安全地调用 wait()。  
  
### **	2. 变量上的 const**  
```
const int a = 10;   // a 不能被修改

```
### **	**  
### **	3. 参数上的 const**  
```
void ( const T & ref) // 绑定右值(临时对象),而且也会延长临时对象的生命周期至ref; 确保ref不能修改

```
  
## ==语法部门:==&:  
* **==右指引用==**:   
	语法上用&&表示, 可以绑定临时对象  
  
## ==语法部门:==*:  
### **函数指针**  
指针全名为指针变量,用来存储另一个对象的地址  
```
int add(int a, int b) { return a+b; }

```
> - [ ]   
```
int (*fp)(int,int) = add; // 声明一个指针fp，指向返回int，参数(int,int)的函数
int result = fp(2,3);     // 调用函数指针，相当于 add(2,3)

```
👉 可以把它理解为“指向函数的变量”。常用于回调、事件处理。  
  
### 成员指针（类成员函数/变量指针）  
```
struct Foo { 
    int x; 
    void hello() { std::cout << "hi\n"; }
};

// 指向成员变量的指针
int Foo::* p = &Foo::x;   // p 代表 Foo 类的 "x" 成员
Foo f;
f.*p = 10;                // 通过成员指针访问（需要一个对象）
std::cout << f.x;         // 输出 10

// 指向成员函数的指针
void (Foo::* fptr)() = &Foo::hello;
(f.*fptr)();              // 调用对象f的成员函数 hello()

```
👉 成员指针需要结合具体对象（f.*p、f.*fptr）才能使用。  
  
**（7）模板参数（展开）**  
在一些模板语法中 * 会出现于折叠表达式：  
  
```
template<typename... Args>
auto mul(Args... args) {
    return (args * ...); // 折叠表达式，相当于 (((a*b)*c)*d)...
}


```
```
int result = mul(2,3,4); // = 2*3*4 = 24

```
  
## ==语法部门:==**&*const组合**  
### **（1）*& 和 &***  
```
int a = 42;
int* p = &a; //&a使指针p的值为a地址值, *p则等于a的内容值

int& ref = *p;  // &*p = a // 引用ref为a的别名

```
### **（2）&&（右值引用） vs &&（逻辑与）**  
编译器会根据上下文判断。  
### **（3）*const 与 const***  
* int* const p ：常量指针（指针本身不可变，内容可变）。  
* const int* p ：指向常量的指针（不能修改指向的内容）。  
* const int* const p ：指向常量的常量指针。  
```
int a = 1, b = 2;

// int* const p ：常量指针，指针本身不能变
int* const p = &a;
*p = 10;    // ✅ 可以改内容
// p = &b;  // ❌ 不行，p不能改指向

// const int* p ：指向常量的指针，内容不能改
const int* q = &a;
// *q = 10;   // ❌ 不行，不能改a
q = &b;       // ✅ 可以换指向

// const int* const p ：既不能改内容，也不能改指针
const int* const r = &a;
// *r = 10; // ❌

```
* **常量引用**：const==防止修改。==  
```

void print(const std::string& s) { ... }

```
## ==语法部门:==**final**  
**放在类的后面表示类无法被继承, 组织了从类的继承, 放在虚函数后面改虚函数无法被重写, 表示阻止虚函数的重载**  
##   
  
  
  
## ==机制部分:==**一、虚函数（virtual function）**  
* **定义**：在基类函数前加 virtual，让函数支持 ****运行时多态****。  
* **机制**：编译器在对象里隐藏了一个“虚函数表指针”（vptr），指向函数地址表（vtable）。调用时会去查这个表，从而找到正确的函数。  
```
struct Base {
    virtual void foo() { cout << "Base\n"; }
};
struct Derived : Base {
    void foo() override { cout << "Derived\n"; }
};

Base* b = new Derived();
b->foo();  // 输出 "Derived"

```
如果 foo 不是 virtual，上面这行就会输出 "Base"（静态绑定）。即编译期就确认目标函数  
  
**虚函数表**: 每个包含虚函数的类都会生成一个虚函数表, 其存储该类中所有虚函数的地址. 虚函数表是一个指针构成的数组, 每个指针指向一个虚函数的实现代码  
  
**虚函数指针**: 在对象的内存布局中, 编译器会添加一个额外的指针, 称为虚函数指针和虚表指针. 这个指针指向该对象对应的虚函数表, 从而让程序能够动态的调用虚函数.  
  
在编译阶段生成，==虚函数和普通函数一样存放在代码段(即函数代码本身没区别)==，==只是它的指针又存放在了虚表之中, 这便引来了区别: 即在调用方式上靠vtable在运行时查找到实际目标, 非虚函数直接跳固定地址. 这就是动态绑定的实现: 多了一层查表==  
  
==注意:==  
	析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。  
	构造函数不可以为虚函数, 因为虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化  
  
  
## ==机制部分:==**二、函数重载（Overloading）**  
* **定义**：在同一个作用域里，可以有多个同名函数，但参数列表必须不同。  
* **特点**：编译器在编译时决定调用哪个函数（**编译期多态 / 静态多态**）。  
```
void print(int x) { cout << "int: " << x << endl; }
void print(double x) { cout << "double: " << x << endl; }
void print(string s) { cout << "string: " << s << endl; }

print(10);      // 调用 int 版本
print(3.14);    // 调用 double 版本
print("hi");    // 调用 string 版本

```
  
## ==机制部分:==**三、函数重写（Overriding）**  
  
## ==机制部分:==**四、隐藏（Hiding）**  
有时你在派生类里定义了一个和基类同名但不同参数的函数，这会 **隐藏基类的所有同名函数**（而不是重载）。  
```

struct Base {
    void show(int x) { cout << "Base int\n"; }
    void show(double x) { cout << "Base double\n"; }
};
struct Derived : Base {
    void show(int x) { cout << "Derived int\n"; }
};

Derived d;
d.show(3);     // 调用 Derived::show(int)
d.show(3.14);  // ❌ 错误，Base::show(double) 被隐藏

```
如果要保留基类的函数，可以用 using：  
```
struct Derived : Base {
    using Base::show; // 把 Base::show 引入作用域
    void show(int x) { cout << "Derived int\n"; }
};

```
##   
  
  
# **Base *\b = new Derived();**  
这其实涉及到 **继承、指针转换、以及面向对象的“向上转型（upcasting）”**。  

| 概念 | 发生位置  | 关键字/机制                 | 特点          |
| -- | ----- | ---------------------- | ----------- |
| 重载 | 同一作用域 | 无关键字（编译器根据参数决定）        | 编译期多态（静态绑定） |
| 重写 | 继承层次  | virtual + override     | 运行期多态（动态绑定） |
| 隐藏 | 继承层次  | 同名但不同签名                | 基类版本被覆盖掉    |
| 多态 | 泛指行为  | 静态多态（重载、模板）+ 动态多态（虚函数） | “一个接口，多种实现” |
  
### **1. 基本概念**  
假设有下面的类：  
```

class Base {
public:
    int x;
};

class Derived : public Base {   // Derived 是 Base 的子类
public:
    int y;
};

```
* Base 是 **基类**  
* Derived 是 **派生类**，继承了 Base 的成员  
  
**2. 对象内存布局**  
当你写 Derived 对象时，它的内存大致像这样：  
  
[ Base 部分 | Derived 自己扩展的部分 ]  
例如：  
```
Derived d;

```
它的内存里先放一份 Base 的内容（因为 Derived 继承了 Base），然后再放 Derived 自己增加的成员。  
##   
  
  
  
### **3. 为什么 Base* 可以指向 Derived**  
* **向上转型（upcasting）**： 当一个 Derived 对象创建出来时，它 **本质上也是一个 Base 对象**（因为继承保证 Derived 包含 Base 的部分）。  
* 所以，把 Derived* 自动转换成 Base* 是安全的。  
```
Base🌟 b = new Derived()

```
这就像说：**“企鹅（Derived）也是鸟（Base）”**。 所以 “企鹅指针” 可以当作 “鸟指针” 来用。  
==但指针b只能调用Base类的变量及其函数, 不可调用扩展的, 除非Derived* d = static_cast<Derived>(b)==  
  
**4. 如果有虚函数**  
如果 Base 里有虚函数，b 仍然可以通过 **多态** 调用 Derived 的实现：  
```
struct Base {
    virtual void speak() { cout << "Base\n"; }
};
struct Derived : Base {
    void speak() override { cout << "Derived\n"; }
};

Base* b = new Derived();
b->speak();   // 输出 Derived

```
因为虚函数表（vtable）机制保证了多态。  
  
  
# C++ 面向对象（OOP）里的核心机制  
多态、虚函数、重载、重写。它们看起来相似，但本质和用途不同。封装, 继承, 多态属于OOP三大特性, 而特性基于C++ 的语法/机制:  
封装靠: class + 访问控制符 + 函数重载(静态多态)  
继承靠: 类继承语法 + 成员可见性 + 重写  
多态靠: 虚函数 + 模版/重载  
	  
## **一、封装（Encapsulation）**  
将具体实现过程和数据封装为一个类, 只能通过接口访问. 降低偶合性.  
  
  
## **二、继承（Inheritance）**  
子类继承父类的特征和行为, 复用了基类的全体数据和成员函数(== 基类私有成员可以被继承, 但无法访问. 其中构造函数, 析构函数, 友元函数, 静态数据成员/函数不能被继承 ==),   
  
## **三、多态（Polymorphism）**  
多态的意思是：**相同的接口（函数调用），在不同对象上有不同的表现。** 比如“动物都会叫”，但猫叫和狗叫不一样。  
```
struct Animal {
    virtual void speak() { cout << "Animal sound\n"; }
};
struct Cat : Animal {
    void speak() override { cout << "Meow\n"; }
};
struct Dog : Animal {
    void speak() override { cout << "Woof\n"; }
};

Animal*\a1 = new Cat();
Animal*\a2 = new Dog();

a1->speak(); // Meow
a2->speak(); // Woof

```
这里的关键：**基类指针/引用调用函数，但真正执行的是派生类的实现**。  
这种“运行时根据对象类型决定行为”的就是 **运行时多态**。  
  
  
**实现方式**通常有两种: 动态多态, 静态多态(编译期多态)  
	**动态多态**: 利用虚函数实现运行时的多态, 即系统编译时并不知道程序将调用哪一函数, 只有运行到该代码处时才确认跳转地址   
		其中==虚函数是类的成员函数==, ==存在虚函数指针的表叫做虚函数表==, 虚函数表是一个存储类成员虚函数的指针, 每个指针指向调用它的地方, 当子类调用虚函数时, 便从虚表里头找到对应函数指针, 从而实现“谁调用、实现谁”, 从而实现多态  
	**静态多态**: 也成编译期多态. 系统在编译时便确认即将执行的具体函数.   
		通过函数重载(函数名相同, 参数不同, 两个函数在同一作用于), 运算符重载, 和重定义(也叫隐藏, 子类中出现同父类函数名的函数, 则子类默认值调用子类的而隐藏父类同名函数)  
  
**优点**: 加强代码的可扩展性, 可扩展性, 可替换性, 增强程序的灵活性, 提高使用效率, 简化应用代码的编写和修改过程  
	  
  
## 类的生命周期:  
加载、验证、 准备、 解析、 初始化、使用和卸载七个阶段. 其中验证、准备、解析三个部分统称连接  
全局对象在main开始前被创建, main退出后被销毁.  
静态对象在第一次进行作用域时被创建, 在main退出后被销毁  
局部对象在进入作用域时被创建, 退出作用域时被销毁  
New创建的对象直到内存被释放的时候都存在  
  
  
# C++ STL  
C++标准库的重要组成部分，不仅是一个可复用的组件库也是一个包含了数据结构与算法的软件架构，它拥有六大组件分别是：仿函数，算法，迭代器，空间配置器，容器，配接器  
  
## 	vector  
	是一个动态数组, 更具需要自动伸缩.  
	**内部实现上**, vector通过一个指向连续内存的指针来管理对应元素, 并根据需要动态扩容, 分配内存来满足容量需求.  
  
### 	1. **底层数据结构:**  
**		数据数组：**用于存储元素。  
		**容量(capacity)**: 当前已分配内存空间  
		**大小(size): **当前存储的元素个数  
  
### 	2. **内存分配与扩展:**  
	当size > capacity时, vector会进行扩容操作. 扩容的具体方法和增长因子依赖于编译器的实现, 一般翻倍容量, 这可减少频繁扩展的开销.  
		**扩容过程**: 当size() 超过capacity()时, vector会重现分配一块更大内存, 将旧数据的元素复制到新内存中.  
		**扩容代价: **复制导致性能开销, 所以为了避免频繁扩容, vector会在初始时欲分配足够内存或使用reserve()来减少扩容次数  
  
### 	3. 容量与大小的关系:  
	capacity() >= size(); 在增加元素时, 容量会随着需求增长而增大, 但通常增长的速度是指数级的, 即容量通常是前一个容量的两倍. 这中策略减少了多次内存重新分配的频率, 提升了性能  
	  
### 	4. 内存管理和对象存储:  
	vector内部会使用一个连续的内存块来存储数据, 这样能保证:  
        1. 俺索引访问效率O(1), 直接通过偏移量  
        2. 保证缓存局部性(因为内存是连续的)  
  
### 	5. 遍历方式与效率  
	由于vector内部是连续的内存块, 所以可以通过多种方式高效便利  
**		1. 基于索引的访问**：  
```
    	for (int i = 0; i < vec.size(); ++i) {
            std::cout << vec[i] << std::endl;  // 使用索引访问
        }

```
		**2. 基于迭代器的访问:**  
```
		for (vector<type>::iterator it = vec.begin(); it != vec.end(); ++it) {
            std::cout << *it << std::endl;  // 使用迭代器遍历
        }

```
**		3. 基于范围for循环: **  
```
		for (auto& element : vec) {
   			 std::cout << element << std::endl;  // 使用范围 for 遍历
		}

```
### 	6. 常见问题与优化:   
		**动态扩容时性能下降:** 在频繁插入大量元素时, 可能会遇到扩容带来的性能下降, 通过提前reserve()或使用shrink_to_fit()(去除多余内存)可以优化性能  
		**容量过大时: **通过reserve()提前分配内存可以避免扩容,  如果预留的内存太大, 也会浪费内存空间  
  
  
  
	  
## 智能指针  
本质是一个封装了一个原始c++指针的类模版, 为了确保动态内存的安全性而生产的. 实现原理是通过一个对象存储需要被自动释放的资源, 然后依靠对象的析构函数释放资源  
  
==语法作用:==  
	unique_ptr<T>: 独占所有权, 不可复制, 只能移动.  
	shared_ptr<T>: 引用技术, 共享所有权.  
	weak_ptr<T>   : 弱引用, 不增加计数, 解决循环引用问题.  
==实现原理:==  
智能指针本质就是一个包装了指针 + 控制逻辑 的类  
	unique_ptr: 内部只存一个裸指针, 析构时delete.  
	shared_ptr: 内部存裸指针 + 控制块(控制块里有引用计数、弱引用计数). 拷贝时引用计数++, 析构时引用计数—, 到0时释放资源.  
	weak_ptr: 内部只存对控制块的弱引用计数, 不会增加强引用计数, 需要用lock() 转成shared_ptr才能使用  
  
## **匿名函数（lambda）**  
在语法层面, 是一种没有名字的内联函数, 可以想像对象一样定义和传递  
在机制层面, c++ lambda会被编译器翻译成一个匿名类 + operator()的仿函数对象(functor)  
	捕获变量会变成这个匿名类的成员变量  
	[]()…{}相当于创建了一个临时对象, 调用它的operator()()  
  
```
auto lam = [x](int y) { return x + y; };

```
```
// 编译器大致展开成：

```
```
struct __Lambda {
    int x;                  // 捕获变量
    int operator()(int y) { // 调用运算符
        return x + y;

```
```
    }
};
__Lambda lam{x};

```
  
**优点**: 可以免去函数的声明和定义. 这样匿名函数仅在调用函数的时候才会创建函数对象, 而调用结束后立即释放, 比非匿名函数更节省空间  
  
  
## Malloc  
malloc并不是系统调用, 而是C库中的函数, 用于动态分类, 在使用malloc分配内存的时候会有两种方式向操作系统申请堆内存  
**方式1**: 分配内存小于128KB时通过brk()系统调用从堆分配内存, **实现原理**即将堆顶指针向高地址移动, 获取内存空间, 如果使用free释放, 并不会讲内存归还OS, 转而缓存在malloc的内存池中, 待下次使用  
**方式2**:分配内存大雨128KB时通过mmap()系统调用在文件映射区域分配内存, **实现原理**即使用私有匿名映射的方式, 在文件映射去分配一块内存, 也就是从文件映射去拿了一块内存, 当free时, 内存得到真正释放  
  
==注意:==  
	容易造成内存泄露和过多的内存碎片, 影响系统正常运行, 还得注意判断内存是否分配成功, 而且内存释放后(使用free函数之后指针变量p本身保存的地址并没有改变), 需要将p的赋值为NULL拴住野指针  
